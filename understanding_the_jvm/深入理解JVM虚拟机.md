# 深入理解JVM虚拟机

[@toc]

## 类加载子系统

**作用**

- 负责从文件系统或者网络中加载`Class`文件，`Class`文件开头有特定标识，魔术，咖啡baby

- `Classloader`只负责`class`文件的加载，至于是否可运行，则由执行引擎决定

- 加载的类信息存放于称为方法区的内存空间，除了类信息，方法区还会存放运行时常量池信息，还可能包括字符串字面量和数字常量,常量池运行时加载到内存中，即运行时常量池 

  

### 类加载过程

**加载**

加载刚好是加载过程的一个阶段，二者意思不能混淆

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的的静态存储结果转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据访问入口



**链接**

1. 验证

   目的:确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全

   四种验证:

   1）.文件格式验证

   ​	CA FE BA BE(魔数，Java虚拟机识别)、主次版本号、常量池的常量中是否有不被支持的常量类型、指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量

   2）.元数据验证

   对字节码描述的信息进行语义分析，保证描述符合Java规范、类是否有父类，除了Object之外，所有的类都应该有父类、类的父类是否继承了不允许被继承的类（被final修饰的类）、如果这个类不是 抽象类，是否实现了其父类或接口中要求实现的所有方法、类的字段，方法是否与父类的产生矛盾。例如方法参数都一样，返回值不同

   3）.字节码验证

   对类的方法体，进行校验分析，保证在运行时不会做出危害虚拟机的行为、保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现类似于在操作数栈放了一个int类型的数据，使用时却按照long类型加载到本地变量表中的情况、保障任何跳转指令都不会跳转到方法体之外的字节码指令上。

   4）.符号引用验证

   通过字符串描述的全限定名是否能找到对应的类，符号引用中的类、字段、方法的可访问性是否可被当前类访问

2. 准备

   为类变量分配内存，并且设置该类变量的初始值，即零值，不包含用`final`修饰的`static`，因为`final`在编译的时候就会分配了，准备阶段会显示初始化，不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象一起分配到Java堆中

   ![image-20201014135510420](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014135510420.png)

3. 解析

   将常量池内的符号引用转换为直接引用的过程，事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行，符号引用就是一组符号来描述引用的目标。符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中，直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄，解析动作主要针对类，或接口，字段，类方法，接口方法，方法类型等。对应常量池中的`CONSTANT_Class_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Methodref_info`

**初始化**

初始化阶段是执行类构造器方法<clinit>()的过程，此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来，构造器方法中指令按照语句在源文中出现的顺序执行，<clinit>()不同于类的构造器（关联：构造器是虚拟机视角下的<init>()），若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕，虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁



**补充说明**

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段不一定，在某些情况下可以在初始化阶段之后再开始，为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）

Java虚拟机规范严格规定了，有且只有六种情况，必须立即对类进行初始化

1. 遇到`new`,`getstatic`，`putstatic`或`invokestatic`这四条字节码指令时。即：使用`new`关键字实例化对象、读取或设置一个类型的静态字段（final修饰已在编译期将结果放入常量池的静态字段除外）、调用一个类型的静态方法的时候
2. 对类型进行反射调用，如果类型没有经过初始化，则需要触发初始化
3. 初始化类的时候，发现父类没有初始化，则先触发父类初始化
4. 虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会初始化这个主类
5. 只用JDK7中新加入的动态语言支持，如果一个`java.lang.invoke.MethodHandler`实例最后的解析结果为`REF_getStatic`,`REF_putStatic`,`REF_invokeStatic`，`REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法对应的类没有进行初始化，则先触发其初始化
6. 当一个接口中定了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，要先将接口进行初始化

除了以上几种情况，其他使用类的方式被看做是对类的被动使用，都不会导致类的初始化



#### 类加载器分类

类加载器可以分为如下几类：

![image-20201014141024393](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014141024393.png?raw=true)

引导类加载器和自定义加载器，概念上，将所有派生于抽象类`ClassLoader`的类加载器都划分为自定义加载器

![image-20201014141226716](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014141226716.png?raw=true)

代码样例，获取类加载器：

```java
  		//获取系统类加载器 sun.misc.Launcher$AppClassLoader@18b4aac2
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        //获取系统类加载器上层：拓展类加载器 sun.misc.Launcher$ExtClassLoader@1ed4004b
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);

        //获取上层 null
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);

        //对用户自定义来说  sun.misc.Launcher$AppClassLoader@18b4aac2
        ClassLoader classLoader = Test.class.getClassLoader();
        System.out.println(classLoader);
```

对于用户来说定义器来说，默认使用系统类加载器进行加载，Java的核心类库，使用引导类加载器进行加载

#### 启动类加载器

C/C++语言实现，嵌套JVM内部，用来加载Java核心类库，`rt.jar,resources.jar,sun.boot.class.path`路径下的内容，并不继承java.lang.ClassLoader，没有父加载器，加载扩展类和应用程序类加载器，并指定为他们的父类加载器，出于安全考虑，Bootstrap启动类加载器只加载包名为`java\javax\sun`等开头的类

```java
 //获取bootstrapClassLoader能加载的api的路劲
 URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
```



#### 扩展类加载器

Java语言编写，由`sun.misc.Launcher$ExtClassLoader`实现，派生于`ClassLoader`类，父类加载器为启动类加载器，从`java.ext.dirs`系统属性所指定的目录中加载类库，或从jre/lib/ext子目录下加载类库



#### 应用程序类加载器（系统类加载器）

Java语言编写，由`sun.misc.Launcher$AppClassLoader`实现，派生于`ClassLoader`类，父类加载器为扩展类加载器，负责加载环境变量classpath或系统属性java.class.path指定路径下的类库，该类加载器是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载，通过`ClassLoader#getSystemClassLoader（）`方法可以后去到改类加载器



#### 用户自定义类加载器

**为什么要使用自定义类加载器**

1. 隔离加载类，例如使中间件的Jar包与应用程序Jar包不冲突
2. 修改类加载的方式，启动类加载器必须使用，其他可以根据需要自定义加载
3. 扩展加载源
4. 防止源码泄露，对字节码进行加密，自定义类加载器实现解密

**实现步骤**

继承抽象类`java.lang.ClassLoader`类的方式，实现自己的类加载器

1.2之前，继承并重写loadClass方法，1.2之后，建议把自定义的类加载逻辑写在`findClass()`方法中

如果没有太过复杂的需求，可以直接继承`URLClassLoader`类，可以避免自己编写`findClass`（）方法，及其获取字节码流的方式，使自定义类加载器编写更加简洁



### 双亲委派模型

**原理**

Java虚拟机对Class文件采用的是按需加载，而且加载class文件时，Java虚拟机使用的是双亲委派模式，即把请求交由父类处理，它是异种任务委派模式

![image-20201014143653893](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014143653893.png?raw=true)

1、如果一个类加载器收到了类加载请求，它并不会自己先去加载。而是把这个请求委托给父类的加载器去执行

2、如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器

3、如果父类的加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

**优势**：避免类的重复加载、保护程序安全，防止核心API被篡改

**沙箱安全机制**：保证对Java核心源代码的保护



**补充**

1. 在JVM中表示两个`class`对象，是否为同一个类存在两个必要条件：类的完整类名必须一致，包括包名、加载这个类的ClassLoader必须相同
2. JVM必须知道一个类型是由启动类加载器加载的，还是由用户类加载器加载的。如果是用户类加载器加载的，JVM会将这个类加载器的一个引用作为类型信息的一部分，保存到方法区中。



## 运行时数据区

JVM虚拟机整体结构

![image-20201014145017623](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014145017623.png?raw=true)

### 程序计数器（PC寄存器）

1. 运行时数据区中唯一不会出现OOM的区域，没有垃圾回收
2. 当前线程所执行的字节码的行号指示器，为了线程切换后能恢复到正确的位置
3. 每个线程有一个独立的程序计数器，线程之间互不影响。
4. 如果线程执行的Java方法，则计数器记录正在执行的虚拟机字节码的指令的地址
5. 如果正在执行的本地方法，这个计数器值则应为空。（undefined）



### 虚拟机栈

**内存中的栈与堆**：栈是运行时的单位，而堆是存储的单位，栈解决程序如何执行，如何处理数据。堆解决的是数据存储问题，即数据怎么放，放在哪里。

**基本内容**

- Java虚拟机栈，早起也叫Java栈，每个线程创建时都会创建一个虚拟机栈，内部保存一个个栈帧，对应着一次次的Java方法调用
- 生命周期和线程的一致
- 主管Java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。

**优点**

- 快速有效的存储方式，访问速度仅次于程序计数器
- JVM直接对JAVA栈的操作只有两个（入栈，压栈）
- 栈不存在垃圾回收，但是存在OOM，Java栈大小是动态或者固定不变的。如果是动态扩展，无法申请到足够内存OOM，如果是固定，线程请求的栈容量超过固定值，则`StackOverflowError`

使用`-Xss` (记忆：站着做一个小手术，栈Xss)，设置线程的最大栈空间

#### **栈的存储单位**

每个线程都有自己的栈，栈中的数据以栈帧格式存储

线程上正在执行的每个方法都各自对应一个栈帧

栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各个数据信息

先进后出，后进先出

一条活动的线程中，一个时间点上，只会有一个活动的栈帧。只有当前正在执行的方法的栈顶栈帧是有效的，这个称为当前栈帧，对应方法是当前方法，对应类是当前类

执行引擎运行的所有字节码指令只针对当前栈帧进行操作

如果方法中调用了其他方法，对应的新的栈帧会被创建出来，放在顶端，成为新的当前帧

#### 栈运行原理

不同线程中包含的栈帧不允许存在相互引用。

当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为新的栈帧。

Java方法有两种返回方式，一种是正常的函数返回，使用`return`指令，另外一种是抛出异常，不管哪种方式，都会导致栈帧被弹出

#### 栈的内部结构

##### 局部变量表

定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及`return` `address`类型，局部变量表建立在线程的栈上，是线程私有的，因此不存在数据安全问题，局部变量表容量大小是在编译期确定下来的，局部变量表存放编译期可知的各种基本数据类型（8种），引用类型（reference）,`return` `address` 类型。最基本的存储单元是slot，32位占用一个slot，64位类型（`long`和`double`）占用两个slot，局部变量表中的变量只有在当前方法调用中有效，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁

**对于槽的理解**

JVM虚拟机会为局部变量表中的每个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值

![image-20201014150557653](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014150557653.png?raw=true)

如果当前帧是由构造方法或者实例方法创建的，那么该对象引用`this`，会存放在index为0的slot处，其余的参数表顺序继续排列

栈帧中的局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的

![image-20201014150625379](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014150625379.png?raw=true)

##### 操作数栈

在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈

如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令

Java虚拟机的解释引擎是基于栈的执行引擎，其中栈就是操作数栈

主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间

当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的

每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好

栈中，32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度

操作数栈并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问

**栈顶缓存技术**：由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理CPU的寄存器中，依此降低对内存的读写次数，提升执行引擎的执行效率



##### 动态链接

指向常量池的方法引用

每一个栈帧内部都包含一个指向运行时常量池中，该帧所属方法的引用

目的是为了支持当前方法的代码能够实现动态链接，比如`invokedynamic`指令

在java源文件被编译成字节码文件中时，所有的变量、方法引用都作为符号引用，保存在class文件的常量池中。

描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的。

动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用



##### 方法返回地址

存放调用该方法的pc寄存器的值，方法的结束，正常执行完成或出现未处理异常，非正常退出，无论哪种方式退出，方法退出后，都会返回该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。异常退出的，返回地址是通过异常表来确定，栈帧中一般不会保存这部分信息。执行引擎遇到任意一个方法返回的字节码指令（`return`）,会有返回值传递给上层的方法调用者，简称正常完成出口，返回指令包括

- `ireturn`返回值是`boolean`，`byte`，`char`，`short`，和`int`类型时使用
- `lreturn`
- `dreturn`
- `areturn`（引用类型）
- 还有一个`return`指供声明为 `void`的方法、实例初始化方法、类和接口的初始化方法使用

本质上，方法的退出就是当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去。

正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值



##### 一些附加信息

允许携带与Java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息。不确定有，可选情况



##### 方法的调用

**静态链接**

当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接

**动态链接**

如果被调用的方法无法再编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接

**方法的绑定**

绑定是一个字段、方法、或者类在符号引用被替换为直接引用的过程。仅仅发生一次。

早期绑定：被调用的目标方法如果再编译期可知，且运行期保持不变

晚期绑定：被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。

Java中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++中则使用关键字virtual来显式定义

如果在java程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字final来标记这个方法

**虚方法和非虚方法**

非虚方法：如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法，静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法

其他方法称为虚方法

**普通调用指令**

`invokestatic`：调用静态方法，解析阶段确定唯一方法版本

`invokespecial`：调用<init>方法，私有及父类方法，解析阶段确定唯一方法版本

`invokevirtual`：调用所有虚方法

`invokeinterface`：调用接口方法

其中`invokestatic`指令和`invokespecial`指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法

> 动态调用指令JDK1.7新增
>
> `invokedynamic`：动态解析出需要调用的方法，然后执行
>
> 直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式



![image-20201014152842225](https://github.com/DuHy/book-learn-note/blob/main/understanding_the_jvm/src/main/resource/img/image-20201014152842225.png?raw=true)

静态语言和动态语言：区别在于对类型的检查是编译器还是运行期，满足编译期就是静态类型语言，反之就是动态类型语言。Java是静态类型语言，动态调用指令增加了动态语言的特性

**方法重写的本质**

找到操作数栈顶的第一个元素所执行的对象的实际类型，记做C，如果在类型C中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过，则返回`java.lang.IllegalAccessError`异常，否则，按照继承关系从下往上依次对C的各个父类进行上一步的搜索和验证过程。如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError`异常

**虚方法表**

面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引表来代替查找

每个类都有一个虚方法表，表中存放着各个方法的实际入口

虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法也初始化完毕



### 本地方法接口

什么是本地方法：简单讲，就是一个Java调用非Java代码的接口

为什么使用native method：与Java环境外交互，例如与操作系统底层或硬件交换信息时的情况、例如启动一个线程



### 本地方法栈

Java虚拟机栈管理Java方法的调用，而本地方法栈用于管理本地方法的调用

本地方法栈，也是线程私有的。

允许被实现成固定或者是可动态扩展的内存大小。内存溢出情况和Java虚拟机栈相同

使用C语言实现

具体做法是Native Method Stack 中登记native方法，在Execution Engine执行时加载到本地方法库

当某个线程调用一个本地方法时，就会进入一个全新，不受虚拟机限制的世界，它和虚拟机拥有同样的权限。

并不是所有的JVM都支持本地方法，因为Java虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等

Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一
